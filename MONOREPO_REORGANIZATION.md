# Реорганизация монорепозитория RolePlayIdentity

## Обзор

Проект был реорганизован в правильную структуру Nx монорепозитория для улучшения масштабируемости, переиспользования кода и упрощения разработки.

## Структура проекта

```
RPI-Monorepo/
├── apps/                    # Запускаемые приложения
│   ├── client/             # Личный кабинет (React) - ТЯЖЕЛЫЙ UI
│   ├── mdtclient/          # MDT клиент (React) - ЛЕГКИЙ UI
│   └── server/             # Бэкенд (Node.js/Express)
│
├── libs/                    # Общие библиотеки
│   ├── shared-types/       # Общие типы TypeScript
│   ├── shared-schema/      # Схемы базы данных и валидации
│   └── shared-utils/       # Общие утилиты
│
├── nx.json                 # Конфигурация Nx
├── package.json            # Главный package.json
└── tsconfig.base.json      # Главный конфиг TypeScript
```

## Библиотеки

### 1. `libs/shared-types` - Общие типы

**Назначение**: Хранение всех общих типов данных проекта.

**Содержимое**:
- Интерфейсы для API-ответов
- Типы для пользователей, персонажей, департаментов
- WebSocket типы
- Перечисления (enums)

**Использование**:
```typescript
import { User, Character, ApiResponse } from '@roleplay-identity/shared-types';
```

### 2. `libs/shared-schema` - Схемы данных

**Назначение**: Определение структуры базы данных и схем валидации.

**Содержимое**:
- Drizzle ORM схемы таблиц
- Zod схемы валидации
- Типы для вставки данных

**Использование**:
```typescript
import { users, characters, insertUserSchema } from '@roleplay-identity/shared-schema';
```

### 3. `libs/shared-utils` - Общие утилиты

**Назначение**: Функции-помощники, не зависящие от React или Express.

**Содержимое**:
- Форматирование дат
- Валидация данных
- Работа с правами доступа
- API утилиты
- WebSocket утилиты

**Использование**:
```typescript
import { formatDate, hasPermission, createApiResponse } from '@roleplay-identity/shared-utils';
```

## Приложения

### 1. `apps/client` - Личный кабинет

**Назначение**: Полнофункциональный веб-интерфейс для управления персонажами и заявками.

**Особенности**:
- Тяжелый UI с Radix UI компонентами
- Анимации и переходы
- Сложные формы и валидация
- Красивый дизайн с Tailwind CSS

**UI-компоненты**: Собственные компоненты в `apps/client/src/components/`

### 2. `apps/mdtclient` - MDT клиент

**Назначение**: Легкий внутриигровой оверлей для MDT функциональности.

**Особенности**:
- Минималистичный UI
- Быстрая загрузка
- Минимум зависимостей
- Оптимизирован для производительности

**UI-компоненты**: Собственные легкие компоненты в `apps/mdtclient/src/components/`

### 3. `apps/server` - Бэкенд

**Назначение**: API сервер для обработки запросов.

**Особенности**:
- REST API
- WebSocket соединения
- Аутентификация и авторизация
- Работа с базой данных

## Преимущества новой структуры

### 1. Независимость UI
- Каждое приложение имеет свой собственный UI
- Можно полностью переделать дизайн одного приложения без влияния на другие
- Оптимизация под конкретные требования

### 2. Переиспользование логики
- Общие типы данных предотвращают рассинхронизацию
- Общие утилиты исключают дублирование кода
- Единая бизнес-логика

### 3. Типобезопасность
- TypeScript проверяет совместимость типов между приложениями
- Автодополнение и проверка ошибок на уровне IDE
- Защита от ошибок во время компиляции

### 4. Оптимизация производительности
- MDT клиент не загружает тяжелые UI зависимости
- Каждое приложение оптимизировано под свои задачи
- Меньший размер бандлов

## Миграция существующего кода

### Шаг 1: Обновление импортов типов

Замените прямые импорты на импорты из библиотек:

```typescript
// Было
import { User } from '../types/user';

// Стало
import { User } from '@roleplay-identity/shared-types';
```

### Шаг 2: Обновление импортов утилит

```typescript
// Было
import { formatDate } from '../utils/date';

// Стало
import { formatDate } from '@roleplay-identity/shared-utils';
```

### Шаг 3: Обновление импортов схем

```typescript
// Было
import { users } from '../db/schema';

// Стало
import { users } from '@roleplay-identity/shared-schema';
```

## Команды Nx

### Разработка
```bash
# Запуск всех приложений
npm run dev:all

# Запуск только клиента
npm run dev:client

# Запуск только сервера
npm run dev:server

# Запуск только MDT клиента
npm run dev:mdtclient
```

### Сборка
```bash
# Сборка всех проектов
npm run build:all

# Сборка только библиотек
nx build shared-types
nx build shared-utils
nx build shared-schema
```

### Тестирование
```bash
# Тестирование всех проектов
npm run test

# Тестирование конкретной библиотеки
nx test shared-types
```

### Линтинг
```bash
# Линтинг всех проектов
npm run lint

# Линтинг конкретной библиотеки
nx lint shared-types
```

## Добавление новых типов

### В shared-types

1. Создайте файл типов в `libs/shared-types/src/`
2. Экспортируйте типы из `libs/shared-types/src/index.ts`

### В shared-utils

1. Создайте файл в `libs/shared-utils/src/`
2. Экспортируйте функцию из `libs/shared-utils/src/index.ts`

### В shared-schema

1. Создайте схему в `libs/shared-schema/src/`
2. Экспортируйте схему из `libs/shared-schema/src/index.ts`

## Лучшие практики

### 1. Разделение ответственности
- **apps/*** отвечают за представление (View)
- **libs/*** отвечают за бизнес-логику и модели данных (Model/Controller)

### 2. Независимость UI
- Каждое приложение имеет свой собственный набор UI-компонентов
- Не создавайте общие UI-компоненты между приложениями
- Используйте общие типы и утилиты

### 3. Оптимизация зависимостей
- MDT клиент должен иметь минимум зависимостей
- Клиент может использовать тяжелые UI библиотеки
- Сервер не должен зависеть от UI библиотек

### 4. Версионирование
- Используйте семантическое версионирование
- Обновляйте версии библиотек при breaking changes
- Документируйте изменения в CHANGELOG

## Планы развития

### Краткосрочные цели
- [x] Удалить shared-ui библиотеку
- [ ] Оптимизировать зависимости для MDT клиента
- [ ] Добавить тесты для всех библиотек
- [ ] Создать документацию API

### Долгосрочные цели
- [ ] Создать CLI для генерации типов
- [ ] Добавить автоматическую проверку типов
- [ ] Интеграция с CI/CD
- [ ] Мониторинг использования библиотек

## Заключение

Новая структура монорепозитория обеспечивает:
- Лучшую организацию кода
- Независимость UI между приложениями
- Повышенную производительность разработки
- Улучшенную типобезопасность
- Легкость масштабирования проекта

Следуйте этой документации для поддержания качества и консистентности кода в проекте. 